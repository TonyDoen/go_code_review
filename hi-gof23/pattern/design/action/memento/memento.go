package memento

/**
 * 备忘录模式是一种软件设计模式：
 * 在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
 * 这样以后就可将该对象恢复到原先保存的状态。
 *
 * 这也是一种比较常见的设计模式，可以用来创建程序某个时刻运行状态的快照，当程序异常崩溃或者因为其他原因导致退出后，可以使用备忘后的数据，恢复到原始状态，最常见的操作应该就是编辑器的撤销了，编辑器应用了备忘录模式，将编辑过程中的代码状态放在一个状态栈中，当使用ctrl+z 的时候，就从栈中弹出上一次保存的状态，来恢复到上一次的情况（即撤销）。
 * 主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，
 * 通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。
 *
 *
 * 备忘录模式的角色
 * 1. 发起人: 发起人的内部要规定要备忘的范围，负责提供备案数据 (Original 类)
 * 2. 备忘录: 存储发起人对象的内部状态，在需要的时候，可以向其他人提供这个内部状态，以方便负责人恢复发起人状态 (Memento  类)
 * 3. 负责人: 负责对备忘录进行管理（保存或提供备忘录） (Storage  类)
 *
 * Original 类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。
 * Memento  类是备忘录类，
 * Storage  类是存储备忘录的类，持有Memento类的实例，该模式很好理解。
 *
 *
 *
 *
 * 上面就是一个单一状态的备忘录模式的完整流程了，还可以做很多操作，比如把保存的备忘录序列化成字符串保存在磁盘中，下次启动的时候从磁盘中获取状态，这样就可以做一个简单的快照了。
 * 当然还有多状态的，一般来说，一个对象有一个对应的备忘对象，记录对象中要备忘的字段，而多个对象的备忘，同一由同一个负责人进行管理，可以用 map 来做到这一点，
 * 负责人中的备忘容器是一个map类型的数据，值是一个实现备忘接口的数据结构即可。
 *
 * 备忘模式的优点:
 * 备忘录模式仅做数据备忘，不论该数据是否正确。
 * 设计模式最大的优点就是解耦，各司其职，发起人只需要提供备忘数据，不需要对其进行管理
 *
 * 备忘模式的缺点
 * 实际应用中，备忘录模式大多是多状态的，如果进行大量备忘的话，会占用大量内存，当然，如果持久化在磁盘中的话，会减少内存占用，但会增加IO操作，这就需要开发者根据实际业务情况进行取舍了。
 */

// 1. 发起人
type Original struct {
	state string // 这里就简单一点，要保存的状态就是一个字符串
}

func (o *Original) SetState(s string) {
	o.state = s
}

func (o *Original) GetState() string {
	return o.state
}

// 这里就是规定了要保存的状态范围
func (o *Original) CreateMemento() *Memento {
	return &Memento{state: o.state}
}

// 2. 备忘录
type Memento struct {
	state string // 这里就是保存的状态
}

func (m *Memento) SetState(s string) {
	m.state = s
}

func (m *Memento) GetState() string {
	return m.state
}

// 3. 负责人
type Storage struct {
	memento *Memento
}

func (c *Storage) GetMemento() *Memento {
	return c.memento
}

func (c *Storage) SetMemento(m *Memento) {
	c.memento = m
}

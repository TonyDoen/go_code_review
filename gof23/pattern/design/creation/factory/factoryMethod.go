package factory

/**
 * 工厂方法模式（Factory Method Pattern）又称为工厂模式，也叫多态工厂模式或者虚拟构造器模式。在工厂方法模式中，工厂父类定义创建产品对象的公共接口，具体的工厂子类负责创建具体的产品对象。每一个工厂子类负责创建一种具体产品。
 *
 * 工厂方法模式角色划分
 * 1. 抽象产品（或者产品接口），如 Car
 * 2. 具体产品，              如 BMWCar, BenzCar
 * 3. 抽象工厂（或者工厂接口），如 CarFactory
 * 4. 具体工厂，              如 BMWCarFactory, BenzCarFactory
 *
 *
 * 工厂方法模式优点
 * 1. 因为每个具体工厂类只负责创建产品，没有简单工厂中的逻辑判断，因此符合单一职责原则。
 * 2. 与简单工厂模式不同，工厂方法并不使用静态工厂方法，可以形成基于继承的等级结构。
 * 3. 新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可，相比于简单工厂模式需要修改判断逻辑而言，工厂方法模式更符合开-闭原则。
 *
 * 工厂方法模式缺点
 * 1. 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
 * 2. 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要换用另外一种产品，仍然需要修改实例化的具体工厂。
 * 3. 一个具体工厂只能创建一种具体产品
 *
 *
 * 简单工厂模式与OOP原则
 * 已遵循的原则
 * 依赖倒置原则
 * 迪米特法则
 * 里氏替换原则
 * 接口隔离原则
 * 单一职责原则（每个工厂只负责创建自己的具体产品，没有简单工厂中的逻辑判断）
 * 开闭原则（增加新的产品，不像简单工厂那样需要修改已有的工厂，而只需增加相应的具体工厂类）
 *
 * 未遵循的原则
 * 开闭原则（虽然工厂对修改关闭了，但更换产品时，客户代码还是需要修改）
 *
 */

type FruitPicker interface {
	MakeFruit() Fruit
}

type Fruit interface {
}

type Banana struct {
	desc string
}

type BananaPicker struct {
}

func (_ BananaPicker) MakeFruit(fruitName string) Fruit {
	switch fruitName {
	case "banana":
		return Banana{"我是一根香蕉"}
	default:
		return Apple{"可能我是一个苹果吧"}
	}
}

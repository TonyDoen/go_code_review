package strategy

/**
 * url: https://github.com/silsuer/golang-design-patterns/tree/master/strategy-pattern
 *
 * 策略模式类图
 *  ________________________            ________________________
 * |       Context          |          |   <<ISortStrategy>>    |
 * |------------------------|          |------------------------|
 * |-strategy:ISortStrategy |<>------->|+Sort()                 |
 * |------------------------|          |________________________|
 * |+Sort()                 |                  /\
 * |________________________|         _  _  _ _|_ _ _ _ _
 *                                   |                   |
 *                  _________________|_____         _____|_________________
 *                 |  BubbleSortStrategy   |       | MergeSortStrategy     |
 *                 |-----------------------|       |-----------------------|
 *                 |                       |       |                       |
 *                 |_______________________|       |_______________________|
 *                 |+Sort()                |       |+Sort()                |
 *                 |_______________________|       |_______________________|
 *
 * 策略模式角色划分
 * 1. Strategy         策略接口或者（抽象策略类），定义策略执行接口
 * 2. ConcreteStrategy 具体策略类
 * 3. Context          上下文类，持有具体策略类的实例，并负责调用相关的算法
 *
 * 策略模式分析
 *
 * 策略模式优点
 * 1. 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法（策略），并且可以灵活地增加新的算法（策略）。
 * 2. 策略模式通过Context类提供了管理具体策略类（算法族）的办法。
 * 3. 结合简单工厂模式和Annotation，策略模式可以方便的在不修改客户端代码的前提下切换算法（策略）。
 *
 * 策略模式缺点
 * 1. 传统的策略模式实现方式中，客户端必须知道所有的具体策略类，并须自行显示决定使用哪一个策略类。但通过本文介绍的通过和Annotation和简单工厂模式结合，可以有效避免该问题
 * 2. 如果使用不当，策略模式可能创建很多具体策略类的实例，但可以通过使用上文《Java设计模式（十一） 享元模式》介绍的享元模式有效减少对象的数量。
 *
 *
 * 定义一组算法，将每个算法都封装起来，并且使他们之间可以互换
 * 在实际应用中， 我们对不同的场景要采取不同的应对措施，也就是不同的策略，比如一个对数据排序的方法，根据数据量和数据特征的不同，我们需要调用不同的排序方法，我们可以把所有的排序算法都封装在同一个函数中，然后通过if...else的形式来调用不同的排序算法，这种方式称之为硬编码，可是在实际应用中，功能和体量的不断增长就会使得我们要经常修改源代码，让这个函数越来越难以维护。所以还是为了解耦，策略模式定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法（即策略），策略模式和模板模式有些相似，需要定义一个抽象类来作为策略的基本模板，每一种策略就是这个抽象类延伸出来的具体类来。
 */

import "fmt"

// 1. 定义抽象策略接口
type ISortStrategy interface {
	Sort() // 对列表进行排序
}

// 2. 定义具体策略
type BubbleSortStrategy struct {
}

func (b BubbleSortStrategy) Sort() {
	fmt.Println("这是冒泡排序")
}

type MergeSortStrategy struct {
}

func (m MergeSortStrategy) Sort() {
	fmt.Println("这是归并排序")
}

// 3. 定义上下文
type Context struct {
	strategy ISortStrategy  // 上下文中指定的策略
}

func (c Context) Sort() {
	c.strategy.Sort()
}
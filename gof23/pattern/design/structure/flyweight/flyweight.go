package flyweight

/**
 * 享元模式（Flyweight Pattern）类图
 *
 *                                                    _________________________________
 *  _______________________________________           |          <<IFlyWeight>>        |
 * |             FlyWeightFactory          |          |--------------------------------|
 * |---------------------------------------|          |                                |
 * |                                       |<>------->|+action(String os): void        |
 * |---------------------------------------|          |________________________________|
 * |+getFlyWeight(String name): FlyWeight  |                  /\
 * |_______________________________________|         _________|_________
 *                                                  |                   |
 *                            ______________________|_________     _____|__________________________
 *                           |       ConcreteFlyWeight        |   |       UnSharedFlyWeight        |
 *                           |--------------------------------|   |--------------------------------|
 *                           |                                |   |                                |
 *                           |________________________________|   |________________________________|
 *                           |+action(String os): void        |   |+action(String os): void        |
 *                           |________________________________|   |________________________________|
 *
 *
 * 享元模式（Flyweight Pattern），又称轻量级模式（这也是其英文名为FlyWeight的原因），通过共享技术有效地实现了大量细粒度对象的复用。
 *
 * 享元模式角色划分:
 * 1. FlyWeight                  享元接口或者（抽象享元类），定义共享接口
 * 2. ConcreteFlyWeight          具体享元类，该类实例将实现共享
 * 3. UnSharedConcreteFlyWeight  非共享享元实现类
 * 4. FlyWeightFactory           享元工厂类，控制实例的创建和共享
 *
 * 内部状态 vs. 外部状态
 * 内部状态是存储在享元对象内部，一般在构造时确定或通过setter设置，并且不会随环境改变而改变的状态，因此内部状态可以共享。
 * 外部状态是随环境改变而改变、不可以共享的状态。外部状态在需要使用时通过客户端传入享元对象。外部状态必须由客户端保存。
 *
 *
 * 享元模式适用场景:
 * 面向对象技术可以很好的解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。
 * 当对象数量太多时，将导致对象创建及垃圾回收的代价过高，造成性能下降等问题。
 * 享元模式通过共享相同或者相似的细粒度对象解决了这一类问题。
 *
 *
 * 享元模式优点:
 * 1. 享元模式的外部状态相对独立，使得对象可以在不同的环境中被复用（共享对象可以适应不同的外部环境）
 * 2. 享元模式可共享相同或相似的细粒度对象，从而减少了内存消耗，同时降低了对象创建与垃圾回收的开销
 *
 * 享元模式缺点
 * 1. 外部状态由客户端保存，共享对象读取外部状态的开销可能比较大
 * 2. 享元模式要求将内部状态与外部状态分离，这使得程序的逻辑复杂化，同时也增加了状态维护成本
 *
 *
 * 已遵循的原则:
 * 1. 依赖倒置原则
 * 2. 迪米特法则
 * 3. 里氏替换原则
 * 4. 接口隔离原则
 * 5. 单一职责原则
 * 6. 开闭原则
 *
 * 享元模式中，最关键的享元工厂。它将维护已创建的享元实例，并通过实例标记（一般用内部状态）去索引对应的实例。当目标对象未创建时，享元工厂负责创建实例并将其加入标记-对象映射。当目标对象已创建时，享元工厂直接返回已有实例，实现对象的复用。
 * 享元模式中对象的复用完全依靠享元工厂。同时本例中实现了对象创建的懒加载。并且为了保证线程安全及效率，本文使用了双重检查（Double Check）。
 *
 *
 *
 * 在一个系统中如果有多个相同的对象，那么只共享一份就可以了，不必每个都去实例化一个对象。
 * 比如说一个文本系统，每个字母定一个对象，那么大小写字母一共就是52个，那么就要定义52个对象。
 * 如果有一个1M的文本，那么字母是何其的多，如果每个字母都定义一个对象那么内存早就爆了。
 * 那么如果要是每个字母都共享一个对象，那么就大大节约了资源。
 *
 * 在Flyweight模式中，由于要产生各种各样的对象，所以在Flyweight(享元)模式中常出现Factory模式。
 * Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个对象存储池（Flyweight Pool）来存放内部状态的对象。
 * Flyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.
 *
 */

// 1. 抽象享元类
type FlyWeight interface {
	Action(externalState string)
}

// 2. 具体享元类
type ConcreteFlyWeight struct {
	name string
}

func (c *ConcreteFlyWeight) Action(externalState string) {
	println("name = " + c.name + ", outerState = " + externalState + ", Action ")
}

// 4. 享元工厂类
type FlyWeightFactory struct {
	m map[string]FlyWeight
}

func (f *FlyWeightFactory) GetFlyWeight(name string) FlyWeight {
	res := f.m[name]
	if nil == res {
		tmp := &ConcreteFlyWeight{name: name}
		f.m[name] = tmp
		return tmp
	}
	return res
}

func NewFlyWeightFactory() *FlyWeightFactory {
	return &FlyWeightFactory{m: make(map[string]FlyWeight)}
}

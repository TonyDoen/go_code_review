package algorithm

/**
 * 030-连续子数组的最大和
 *
 * 给一个数组，返回它的最大连续子序列的和？(子向量的长度至少是1)
 * 例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。
 *
 * 思路：
 * 令 函数 f(i)表示以第 i 个数字结尾的子数组的和，那我们这要求出 max(f(i)), i=1,2,...,n
 *        | arr[i]              i=0 or f(i-1)<=0
 * f(i) = {
 *        | arr[i] + f(i-1)    i!=0 or f(i-1)>0
 *
 * 从动态规划的状态转移方程来看，本来需要维护一张二维表记录每个阶段的最大和，再取最大值即为所求问题的解。
 * 但是 f(i) 只与 f(i−1) 状态有关，那么用一个临时变量记录 f(i−1), 另一个变量记录最大值，就可将空间复杂度降为常数级。
 *
 * 时间复杂度O(n)，空间复杂度O(1)
 */
func FindGreatestSum(arr []int) int {
	if nil == arr {
		return -1
	}
	length, sum, max := len(arr), arr[0], arr[0]
	for i := 1; i < length; i++ {
		if sum <= 0 { // 如果sum <= 0，说明位置i之前的元素之和对后面的元素产生负影响或者没有影响，那么就需要抛弃之前的连续子序列,
			sum = arr[i]
		} else { // 否则，保留之前的连续子序列以及其和，接着向后遍历
			sum += arr[i]
		}

		if sum > max {
			max = sum
		}
	}
	return max
}

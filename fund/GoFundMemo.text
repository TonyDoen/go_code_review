
go 中切片 slice
    本身不是数组，切片指向底层数组，作为变长数组的替代方案，可关联底层数组的局部或全部
    切片是引用类型
    可以直接创建，
    使用len() 获取元素个数，cap() 获取容量
    一般使用make() 创建，# slice1 = make([]string, len, cap), cap可以省略，len表示元素个数，cap表示容量
    若，多个slice 指向同一个数组底层，其中一个值改变会影响全部
    reslice
    重新切片：索引以被slice的切片为准
              索引不可以超过被切片的数组容量
              索引越界会引发错误
    append(),
    添加切片，使用内嵌函数
              可以在切片尾部追加元素，可以一个切片追加到另一个切片
              若，长度未超过追加切片的数组容量，返回原始切片；若，超过切片容量，重新分配数组，并复制原始数据 
    copy()
    复制切片，使用内嵌函数
    

go 中函数 function
    go函数 不支持 嵌套，重载，默认参数
    go函数 支持 无需申明原型（vs. c/c++）,不定长度变参(在参数列表中的最后一个)，多返回值，命名返回值参数，匿名函数(不能作为最外层函数)，闭包
    
    定义函数使用 func，且左大括号不能另起一行，
    函数可以作为一种类型使用
    
go 中关键字 defer
    执行方式类似java，c++中的析构函数，函数体执行结束后 按照调用顺序的 相反顺序 逐一执行
    即使发生 严重错误 也会执行
    支持匿名函数调用，通过与匿名函数配合在return 后修改函数计算结果
    常用于 资源清理，文件关闭，解锁，及记录日志或者时间等

    go 中没有异常机制，使用 panic/recover 模式来处理错误
    panic 可以在任何地方引发，但 recover 只能在 defer 调用的函数中有效, 用于处理panic的defer函数必须在 panic发生之前
    
